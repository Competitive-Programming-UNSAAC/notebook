\section{Data Structures}

\Algorithm{Union Find}
{Union Find and Union Find with Rank}
{$\mathcal{O}(n)$}
{cpp}{\code{UnionFind.cpp}}
{mazapan}

\Algorithm{Trie Iterative}
{Trie Iterative}
{$\mathcal{O}(n)$}
{cpp}{\code{TrieIterativo.cpp}}
{mazapan}

\Algorithm{Trie Recursivo}
{Trie Recursivo}
{$\mathcal{O}(n)$}
{cpp}{\code{TrieRecursivo.cpp}}
{mazapan}

\Algorithm{Segment Tree with Lazy Propagation}
{Segment Tree with Lazy Propagation for RMQ}
{$\mathcal{O}(nlogn)$}
{cpp}{\code{SegmentTreeLazyPropagation.cpp}}
{mazapan}

\Algorithm{Sparse Table}
{RMQ in O(1)}
{$\mathcal{O}(nlogn)$}
{cpp}{\code{SparseTable.cpp}}
{mazapan}

\Algorithm{Lower Bound Trick on Arrays}
{find first element at least "x"}
{$\mathcal{O}(nlogn)$}
{cpp}{\code{LowerBound.cpp}}
{mazapan}

\Algorithm{Merge Sort Tree}
{Find lower bound on intervals}
{$\mathcal{O}(nlogn)$}
{cpp}{\code{MergeSortTree.cpp}}
{mazapan}

\Algorithm{Min Stack and Min Queue}
{Trick for DP optimizations}
{$\mathcal{O}(n)$}
{cpp}{\code{MinStackMinQueue.cpp}}
{mazapan}

\Algorithm{Indexed Multiset}
{Fenwick Tree as indexed Multiset}
{$\mathcal{O}(nlogˆ2n)$}
{cpp}{\code{IndexedMultiset.cpp}}
{mazapan}

\Algorithm{Smallest Prime Factor}
{factor numbers quickly}
{$\mathcal{O}(nlogn)$}
{cpp}{\code{SPFqueries.cpp}}
{mazapan}

\section{Graphs}

\Algorithm{Check Bipartite}
{Check Bipartite Graphs}
{$\mathcal{O}(V + E)$}
{cpp}{\code{BipartiteGraph.cpp}}
{mazapan}

\Algorithm{Dijkstra}
{Single Source Shortest Path}
{$\mathcal{O}((V + E)log(V))$}
{cpp}{\code{Dijkstra.cpp}}
{mazapan}

\Algorithm{Dinic Max Flow}
{Find maximum flow on sparse graphs}
{$\mathcal{O}(V^2E)$}
{cpp}{\code{DinicMaxFlow.cpp}}
{mazapan}

\Algorithm{Floyd-Warshall}
{All pair of nodes shortest path}
{$\mathcal{O}(Vˆ3)$}
{cpp}{\code{FloydWarshall.cpp}}
{mazapan}

\Algorithm{Hopcrop-Karp Algo}
{Fastest Maximum Bipartite Matching Algo}
{$\mathcal{O}(sqrt(V)E)$}
{cpp}{\code{hopcropKarp.cpp}}
{mazapan}

\Algorithm{Kahn Topological Order}
{find topological order on DAG}
{$\mathcal{O}(V + E)$}
{cpp}{\code{KahnAlgo.cpp}}
{mazapan}

\Algorithm{Kruskal MST}
{greedy minimum spanning tree}
{$\mathcal{O}(ElogE+E\alpha(V))$}
{cpp}{\code{Kruskal.cpp}}
{mazapan}

\Algorithm{Lowest Common Ancestor}
{lca of 2 nodes with binary lifting}
{$\mathcal{O}((V + E)log(V))$}
{cpp}{\code{LowestCommonAncestor.cpp}}
{mazapan}

\Algorithm{Shortest Path Faster Algorithm}
{SPFA to find negative cycles}
{$\mathcal{O}(VE)$}
{cpp}{\code{ShortestPathFasterAlgorithm.cpp}}
{mazapan}

\Algorithm{Tree Flattening}
{transforming a tree structure into a linear form}
{$\mathcal{O}(V + E)$}
{cpp}{\code{SubTreeQueries.cpp}}
{mazapan}

\Algorithm{Kosaraju Strongly Connected Components}
{Find all SCC and condensation Graph}
{$\mathcal{O}(V + E)$}
{cpp}{\code{Kosaraju.cpp}}
{mazapan}

\Algorithm{Heavy Light Decomposition}
{answer queries in tree paths}
{$\mathcal{O}(nlogn^2)$}
{cpp}{\code{HLD.cpp}}
{mazapan}

\Algorithm{BFS in complement graph}
{This Algorithm traverses the complement graph}
{$\mathcal{O}((n + m)\log{n})$}
{cpp}{\code{BFSComplementGraph.cpp}}
{Jhamsid Bernal}
\progress

\Algorithm{Dijkstra}
{This Algorithm searches the sortest path from a vertix to other vertice}
{$\mathcal{O}(n + m)\log{m}$}
{cpp}{\code{dijkstra.cpp}}
{Cp algorithm}

\Algorithm{Kosaraju Bridges}
{find bridges on a graph}
{$\mathcal{O}(n + m)$}
{cpp}{\code{Bridges.cpp}}
{Mazapan}

\Algorithm{Suffix Automaton distinct substring queries in range}
{distinct substring queries in range}
{$\mathcal{O}{\log{n}}$}
{cpp}{\code{string/SAdistinctsubstringinrange.cpp}}
{Youknowhow}

\section{String}

\Algorithm{Kasai's Algorithm}
{This Algorithm create the lcp array}
{$\mathcal{O}(n)$}
{cpp}{\code{kasai.cpp}}
{Jhamsid Bernal}

\Algorithm{Suffix Array}
{Suffix Array}
{$\mathcal{O}(n \log{n})$}
{cpp}{\code{string/suffixarray.cpp}}
{Jhamsid Bernal}
\progress

\Algorithm{Suffix Automaton}
{Suffix Automaton}
{$\mathcal{O}(n)$}
{cpp}{\code{string/suffixautomaton.cpp}}
{YouKnow}
\progress

\Algorithm{Prefix Function}
{Algorithm to find the prefix value of index i}
{$\mathcal{O}(n)$}
{cpp}{\code{PrefixFunction.cpp}}
{Jhamsid Bernal}
\progress

\Algorithm{Manacher's algorithm}
{This algorithm searches palindromes very fast in two lists; in the first list, contains the largest size of a palindrome odd in the position i, in the second list, contains the largest size of a palindrome even in the position i}
{$\mathcal{O}{n}$}
{cpp}{\code{manacher.cpp}}
{Manacher}

\section{Math}

\Algorithm{FFT}
{This algorithm calcules the multiply of two polynomials}
{$\mathcal{O}{n \log{n}}$}
{cpp}{\code{math/fft.cpp}}
{Youknowhow}

\Algorithm{Inverse Modular}
{This Algorithm searches the inverse modular of a number}
{$\mathcal{O}(\log{n})$}
{cpp}{\code{inverseModular.cpp}}
{David Wärn}

\Algorithm{Mobius}
{This Algorithm searches for each value $i$, its mobius function}
{$\mathcal{O}(n\log{n})$}
{cpp}{\code{Mobius.cpp}}
{Uknown}

\Algorithm{Criba}
{Erasthotenes}
{$\mathcal{O}(n \log{ \log{n}})$}
{cpp}{\code{math/criba.cpp}}
{Cp algortihm}

\Algorithm{FNF}
{This algorithm searches the value of n-th number fibonacci faster}
{$\mathcal{O}(\log{n})$}
{cpp}{\code{math/fnf.cpp}}
{Jhamsid Bernal}

\section{Dynamic Programming}

\Algorithm{Open and Close interval DP}
{This Algorithm solves problem where are groups problems}
{$\mathcal{O}(mn^2)$}
{cpp}{\code{open_close_interval.cpp}}
{Jhamsid Bernal}
\progress

\Algorithm{SOS DP}
{Given a fixed array A of $2^N$ integers, we need to calculate $\forall$
x function $F(x) = Sum of all A[i]$ such that $x\&i = i$, i.e., i is a subset 
of x.}
{$\mathcal{O}(N \cdot 2^N)$}
{cpp}{\code{sosDP.cpp}}
{Jhamsid Bernal}

\Algorithm{Sparse Table}
{RMQ}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{sparsetable.cpp}}
{Cp algorithm}

\section{Other}

\Algorithm{LIS}
{LIS}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{other/lis.cpp}}
{Cp algorithm}

\section{Geometry}

\Algorithm{Closest Pair Of Points}
{Closest Pair Of Points}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{ClosestPairPoints.cpp}}
{Cp algorithm}

\Algorithm{Closest Pair Of Points}
{Closest Pair Of Points}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{ClosestPairPoints.cpp}}
{Cp algorithm}

\Algorithm{Closest Pair Of Points Divide Conquer}
{Closest Pair Of Points Divide Conquer}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{ClosestPairPointsDivideConquer.cpp}}
{Cp algorithm}

\Algorithm{Geometry}
{All geometry}
{$\mathcal{O}{N \log{N}}$}
{cpp}{\code{Geometry.cpp}}
{Cp algorithm}